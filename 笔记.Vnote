è¿™ä¸ªæ–‡ä»¶æ²¡è¢«sourceï¼Œ ä»…ä½œä¸ºé‡‡å‘ç¬”è®°

æ–°å†…å®¹å¾€ä¸‹é¢æ”¾

        " https://github.com/vim/vim/issues/6793
        " Register % contains the name of the current file.
        " è¿™3è¡Œç»“æœè²Œä¼¼ä¸€æ ·, expandå’Œfnamemodifyåªæœ‰ç»†å¾®åŒºåˆ«ï¼Ÿ
        " let $no_vscode = expand('%:h') . "/no_vscode.vim"
        " let $no_vscode = fnamemodify('%',':h') . "/no_vscode.vim"




- expand/æ‰©å±•/è¯†åˆ« æ–‡ä»¶å
        éƒ½ä¸è¡Œ:
        " let $has_vscode = fnamemodify($MYVIMRC,':h') . "/has_vscode.vim"
        " let $has_vscode = expand('%:h') . "/has_vscode.vim"
        " let $has_vscode = fnamemodify('%',':h') . "/has_vscode.vim"


        " echom 'has_vscodeæ‰¾åˆ°äº†å—'
        " echom $has_vscode

- autocmd
        " é”™è¯¯çš„æ ¹æº:  ä½œä¸ºautocmdçš„{pat},  ~ æ— æ³•expandä¸ºå®¶ç›®å½• (ä½†echo $no_vscodeæ—¶åˆå¯ä»¥ï¼‰
        let $no_vscode = "~/dotF/cfg/nvim/no_vscode.vim"

        " Note that special characters (e.g., "%", "<cword>") in the ":autocmd"
        " arguments are not expanded when the autocommand is defined.
        " These will be  expanded when the Event is recognized, and the {cmd} is executed.
        " The only  exception is  "<sfile>"
        "
        "
        æ€ä¹ˆå‘ç°çš„ï¼Ÿ

        :augroup wf_reload ï¼Œ è¾“å‡ºçš„ç»“æœå‘ç°ï¼Œ æƒ³è¦çš„autocmdå®šä¹‰æˆåŠŸ, {pat}æ˜¯ï¼š~/dotF/cfg/nvim/no_vscode.vim

        " let no_vscode = 'hihi'
        " XX å’Œ $XX å¯ä»¥ç‹¬ç«‹ï¼Œçœ‹çœ‹echo $XX å’Œ echo XX
        "
        " let no_vscode = 'hihi'
        " XX å’Œ $XX å¯ä»¥ç‹¬ç«‹ï¼Œçœ‹çœ‹echo $XX å’Œ echo XX

        " æœ€ç»ˆæˆåŠŸçš„å…³é”®ä¸€è¡Œ
        autocmd wf_reload BufWritePost $no_vscode  ++nested   source $MYVIMRC |  echom 'hi'

        " æ²¡é‚£ä¹ˆå¥½ï¼š
        autocmd wf_reload BufWritePost no_vscode.vim  ++nested   source $MYVIMRC |  echom 'hi1'
        autocmd wf_reload BufWritePost *no_vscode.vim  ++nested   source $MYVIMRC |  echom 'hi2'

        " å…¶ä»–æƒ³æ³•
        " " è¿™3ä¸ªéƒ½ä¸è¡Œ
        " autocmd wf_reload BufWritePost no_vscode   echom 'ä½ çœ‹'
        " autocmd wf_reload BufWritePost $no_vscode  echom 'ä½ çœ‹'
        " autocmd wf_reload BufRead     $no_vscode  echom 'ä½ çœ‹'
        " autocmd wf_reload BufRead    *no_vscode.vim       echom 'ä½ çœ‹'
        " autocmd wf_reload BufWritePost     $no_vscode       echom ' èƒ½è¯†åˆ«äº†ï¼š  $no_vscode ï¼ˆç¯å¢ƒå˜é‡ï¼‰'
        " The environment variable is expanded when the autocommand is defined, not when
        " the autocommand is executed.  This is different from the command!

        " æ˜æ˜åˆ«äººéƒ½è¯´è¡Œçš„å•Š https://vi.stackexchange.com/questions/28110/can-i-use-a-variable-in-autocmd-pat
        " è€Œä¸”æœ€åè¿™è¡Œä¹ŸæˆåŠŸäº†å•Šï¼š
        " source $in_vscode
        " è¿™æ ·å¯ä»¥
        " autocmd wf_reload BufWritePost no_vscode.vim  echom "ä½ çœ‹, èƒ½è¯†åˆ«$no_vscode:" | echom $no_vscode | echom ' '
        " todo https://vi.stackexchange.com/questions/6830/putting-the-value-of-an-argument-into-part-of-a-regex-in-vimscript

        " todo: æ”¹æˆåœ¨rc.zshé‡Œå®šä¹‰$no_vscode ?
        "
        "
        "
        " ++nested ï¼Œè€ç‰ˆæœ¬ä¸­æ˜¯nested
                    " Problem:    Making an autocommand trigger once is not so easy.
                    " Solution:   Add the ++once argument.  Also add ++nested as an alias for
                                "nested". (Justin M. Keyes, closes #4100)


        " `:autocmd` adds to the list of autocommands regardless of whether they are
                " already present.  When your .vimrc file is sourced twice, the autocommands
                " will appear twice.  To avoid this, define your autocommands in a group, so
                " that you can easily clear them:
                "
        autocmd BufWritePost *dotF/cfg/nvim/** source %   | echom "æ›´æ–°äº†"."init.vimç³»åˆ— "| redraw
        ä»£æ›¿äº†:
                                                                                        " ç‚¹å·æ‹¼æ¥å­—ç¬¦ä¸²
        " autocmd Reload BufWritePost $MYVIMRC    ++nested   source $MYVIMRC | echom "æ›´æ–°äº†"."init.vim "| redraw
        " autocmd Reload BufWritePost $no_vscode  ++nested   source $MYVIMRC | echom 'æ ¹æ®ç¯å¢ƒå˜é‡ï¼Œæ”¹äº†no_vscode.vim, åŠ è½½äº†init.vim' | redraw
        " autocmd Reload BufWritePost $has_vscode  ++nested  source $MYVIMRC | echom '(æ”¹äº†has_vscode.vim, æ›´æ–°init.vim)'  | redraw



        " When a function by this name already exists and [!] is
        " not used an error message is given.  There is one
        " exception: When sourcing a script again, a function
        " that was previously defined in that script will be
        " silently replaced.
        " When [!] is used, an existing function is silently
        " replaced.  Unless it is currently being executed, that
        " is an error.
        " NOTE: Use ! wisely.  If used without care it can cause
        " an existing function to be replaced unexpectedly,
        " which is hard to debug.

        " æ”¹äº† beautify_wfå¹¶ä¿å­˜åï¼Œ ä¿å­˜init.vimä¼šè¯´function already exist
        " äº›åˆ«æƒ³ç€é¿å…è¿™ä¸ªé—®é¢˜ï¼Œæ¯•ç«Ÿå¾ˆå°‘æ”¹init.vimä»¥å¤–çš„æ–‡ä»¶.
        " https://github.com/xolox/vim-reload

-  " ç¦ç”¨netrwï¼Œä¸è¿‡åº”è¯¥ç”¨ä¸ç€äº†ã€‚æˆ‘åˆ æ‰äº†å¯¹åº”æ–‡ä»¶
        " let g:loaded_netrw       = 1
        " let g:netrw_banner=0
        " let g:loaded_netrwPlugin = 1



-  " " ç«–ç€åˆ†å±æ‰“å¼€help
        " augroup my_filetype_settings
        "     autocmd!
        "     " winnr: å½“å‰windowçš„ç¼–å·ï¼Œtop winodwæ˜¯1
        "     " $  è¡¨ç¤º last window
        "     autocmd FileType help if winnr('$') > 2 | wincmd K | else | wincmd L | endif
        "     augroup end

        " 1.4 LISTING MAPPINGS                  *map-listing*
        " When listing mappings the characters in the first two columns are:

        "       CHAR    MODE    ~
        "      <Space>  Normal, Visual, Select and Operator-pending
        "     n Normal
        "     v Visual and Select
        "     s Select
        "     x Visual
        "     o Operator-pending
        "     ! Insert and Command-line
        "     i Insert
        "     l ":lmap" mappings for Insert, Command-line and Lang-Arg
        "     c Command-line
        "     t Terminal-Job
        "
        " Just before the {rhs} a special character can appear:
        "     * indicates that it is not remappable
        "     & indicates that only script-local mappings are remappable
        "     @ indicates a buffer-local mapping


" *i_CTRL-X* *insert_expand*
        " CTRL-X enters a sub-mode where several commands can be used.  Most of these
        " commands do keyword completion; see |ins-completion|.


        " no help for <C-X>
        " no help for CTRL-X CRTL-O
        " è¿™æ ·æ‰è¡Œï¼š
        " h i_CTRL-X


" ms-windows
        " è¿™æ ·å¯ä»¥ ä¸é‚£ä¹ˆæ­»æ¿åœ° åªèƒ½ç”¨~/AppData/Local/nvim/init.vimæ¥è¿›å…¥windowsçš„nvim, ä»è€Œç®¡ç†æ’ä»¶(
        " windowsçš„nvimå’Œvscodeçš„nvimå…±ç”¨):
        "nvim -u '\\wsl$\Ubuntu\root\dotF\.config\nvim\init.vim'
        " æ’ä»¶ä½ç½®:
        " C:\Users\noway\AppData\Local\nvim-data
        " æŠŠwslä¸‹çš„dotfileå‘é€å¿«æ·æ–¹å¼åˆ° ~/AppData/Local/nvim/init.vim , ä¸è¡Œ.å› ä¸ºshortcutå’Œè½¯é“¾æ¥è¿˜ä¸ä¸€æ ·
        " https://superuser.com/questions/253935/what-is-the-difference-between-symbolic-link-and-shortcut


" Return to last edit position when opening files
        " autocmd BufReadPost * normal! g`"zv
        " æœ‰bug:
        "  normal! è¡¨ç¤º Execute Normal mode commands,
        "  [!] :  mappings will not be used.
        "  g`"è¡¨ç¤º è·³åˆ° the last known position in a file
        "  zv å–æ¶ˆæŠ˜å å…‰æ ‡æ‰€åœ¨è¡Œ
        " å¦‚æœ: the file is truncated outside of vim, and vim's mark is on a line that no longer exists, vim throws an error. Fixed that with:
        " autocmd BufReadPost * silent! normal! g`"zv
        " æˆ–è€…:


" è¿™ä¹ˆå†™æ¯”è¾ƒå•°å—¦ï¼š
"
" let s:beauty_path = fnamemodify($MYVIMRC, ":p:h") . "/lookå¤–è§‚.vim"    " å­—ç¬¦ä¸²concatï¼Œç”¨ç‚¹å·
" exe 'source ' . s:beauty_path      " è¿™æ ·ä¸è¡Œï¼š source  . s:beauty_path

set virtualedit=insert,block
æœ‰äº†ä¸Šé¢é‚£è¡Œ, å°±ä¸éœ€è¦è¦äº†?  :

" toggle virtualedit
    let s:anywhere = 0
    func! Cursor_anywhere_01()
        if s:anywhere == 0
            set virtualedit=all # ä¼šå¯¼è‡´å…‰æ ‡è·³è½¬ä¸èˆ’æœ
            let s:anywhere = 1
        else
            set virtualedit=
            let s:anywhere = 0
        endif
    endfunc

    nnoremap <Leader>aw :call Cursor_anywhere_01()<cr>
    nnoremap <Leader>ji :call Cursor_anywhere_01()<cr>ji


register/å¤åˆ¶ç²˜è´´
            " has({feature}  Returns 1 if {feature} is supported, 0 otherwise
            " å¯¹æ¯”:
            " exists({expr})	The result is a Number, which is |TRUE| if {expr} is  defined, zero otherwise.
            " For checking if a file exists use |filereadable()|.
        if has('clipboard')  " ç¡®è®¤|clipboard| provider is available  (æ‰€ä»¥å‰é¢è¯´  è¦å…ˆå†™å¥½ g:clipboard  ??
                                " æ­¤'clipboard'æ˜¯ä¸€ä¸ªpseudo featureå, ä¸æ˜¯g:clipboardè¿™ä¸ªvariable
        " To ALWAYS use the clipboard for ALL operations (instead of  interacting with the '+' and/or '*' registers explicitly)
        " è®©unnamedå¯„å­˜å™¨(") ä¸€ç›´point to åŠ å·å¯„å­˜å™¨
            " ç¼ºç‚¹: å¯¼è‡´vimå†…ç²˜è´´ è·Ÿè¿œç¨‹ä¼ åˆ°æœ¬åœ° ä¼¼çš„, å¾ˆæ…¢:
            " set clipboard=unnamedplus  " æ­¤å¤„çš„clipboard, æœå¸®åŠ©æ—¶æ•² :help 'clipboard' (å› ä¸ºå®ƒæ˜¯ä¸€ä¸ªoption, ä¸æ˜¯variabel, ä¹Ÿä¸æ˜¯featureå
            " set clipboard=unnamedplus,unnamed
                                        " è¿™ä¼šç»™ * å¯„å­˜å™¨ä¹Ÿå¤åˆ¶ä¸€ä»½
            set clipboard^=unnamed,unnamedplus
                        " ^= è¡¨ç¤ºprepend,  += è¡¨ç¤ºappend  (å¯¹äºstringæ˜¯è¿™æ ·)
                        " åœ¨linux, windowså’Œmacçš„behaviorä¸€è‡´
        else
            set clipboard=unnamed
                    "  è®©unnamedå¯„å­˜å™¨ä¸€ç›´point toæ˜Ÿå·å¯„å­˜å™¨
        endif

            " æ•²"+yyç­‰, ç¡®å®ä¼šåˆ›å»ºç›®å½•:
            " let g:clipboard = {
            "                 \ 'name': 'xsel-remote',
            "                 \ 'copy': {
            "                 \   '+': 'mkdir -p /home/wf/.t/ccccccccccccccccccccåŠ ',
            "                 \   '*': 'mkdir -p /home/wf/.t/ccccccccccccccccccccæ˜Ÿ',
            "                 \  },
            "                 \ 'paste': {
            "                 \   '+': 'mkdir -p /home/wf/.t/ppppppppppppppppppppppåŠ ',
            "                 \   '*': 'mkdir -p /home/wf/.t/ppppppppppppppppppppppæ˜Ÿ',
            "                 \ },
            "                 \ 'cache_enabled': 1,
            "                 \}
            "
            "
            "
            " let g:clipboard = {
            "     \   'name': 'myClipboard',
            "     \   'copy': {
            "     \      '+': ['tmux', 'load-buffer', '-'],
            "     \      '*': ['tmux', 'load-buffer', '-'],å™¨

            " let g:clipboard = {
            "     \   'name': 'myClipboard',
            "     \   'copy': {
            "     \      '+': ['tmux', 'load-buffer', '-'],
            "     \      '*': ['tmux', 'load-buffer', '-'],

            "     \    },
            "     \   'paste': {
            "     \      '+': ['tmux', 'save-buffer', '-'],
            "     \      '*': ['tmux', 'save-buffer', '-'],
            "     \   },
            "     \   'cache_enabled': 1,
            "     \ }
            " let g:clipboard = {
            " \ 'name': 'wf_xclip',
            " \ 'copy': {
            " \   '+': ['xclip', '-selection', 'clipboard', '-silent', '-loop', '2'],
            " \   '*': ['xclip', '-selection', 'primary', '-silent', '-loop', '2'],
            " \  },
            " \ 'paste': {
            " \   '+': 'xclip -selection clipboard -out',
            " \   '*': 'xclip -selection primary  -out',
            " \ },
            " \ 'cache_enabled': 1,
            " \}
            " è¿™æ ·ä¸è¡Œ
            "     '*': 'echom "wf_paste" ; xclip -selection primary  -out',
            " https://stackoverflow.com/a/67229362/14972148
            "
            "
    " v:register	The name of the register in effect for the current normal mode command
        " v:register å–å€¼æƒ…å†µ:
                "  1. if 'clipboard' contains "unnamed" :
                "          echo v:register  è¾“å‡º* (æ˜Ÿå·)
                "  2. if 'clipboard' contains "unnamedplus":
                "          echo v:register  è¾“å‡º+ (åŠ å·)
                "  3. if none is supplied:
                "         echo v:register  è¾“å‡º" (åŒå¼•å·,  default register)
                "
                "
                "
                "
            " xsel:

                    " --input            -i  | read standard input into the selection
                    " --clipboard        -b  | operate on the CLIPBOARD selection
                    " --primary          -p  | operate on the PRIMARY selection (default)
                    " --secondary        -s  | operate on the SECONDARY selection

            " xclip
                    " xclip reads text from standard input or files and makes it available to
                    " other X applications for pasting as an X selection (traditionally with the middle  mouse  button).

                    " The default action is to silently  wait  in  the  background  for `X selection requests (pastes)`
                    " until another X application places data in the clipboard, at which point xclip exits silently.
                    " You can use  the -verbose option to see if and when xclip actually receives
                    " selection requests from other X applications. (TUIçš„è²Œä¼¼ä¸ç®—)

                            " -selection
                            "      specify which X selection to use,
                            "      options are:
                            "         "primary" to use XA_PRIMARY (default),
                            "         "secondary" for XA_SECONDARY or
                            "         "clipboard"  for XA_CLIPBOARD è¿™å‡ ä¸ªå¤§å†™å•è¯, åŠå¤©æ²¡æœåˆ°å‡ºå¤„




statusline
        " set statusline=
        " set statusline=%7*=%r
        " set statusline=%=%t                            " tittle
        " set statusline+=%=\ bufferå·:%n\            "buffer number
        " set statusline+=%=%m                         "modified flag
        " " set statusline+=%=æ–‡ä»¶æ ¼å¼:%{&ff}            "æ˜¯å¦unix
        " " flag[Preview] ??
        " set statusline+=%=\ %h
        " set statusline+=%=\ %w
        " set statusline+=%=\ %k
        " set statusline+=%=\ %q
        " set statusline+=%999X
        " " set statusline+=
        " set statusline+=%=ç¬¬%lè¡Œ/
        " set statusline+=%Lè¡Œ               "total lines
        " set statusline+=(%p%%)
        " set statusline+=%=ç¬¬%våˆ—         "virtual column number (screen column)
        " " set statusline+=\ %c           " Column number (byte index).

        " set statusline+=%2*\ %y\                                  "FileType
        " set statusline+=%3*\ %{''.(&fenc!=''?&fenc:&enc).''}      "Encoding
        " set statusline+=%3*\ %{(&bomb?\",BOM\":\"\")}\            "Encoding2
        "
        "
        "
        "
        "
        "
        "
        "
        "
        "
autocmd



        " å…³äºwindow/buffer/tabçš„enterå’Œleave
        " read file into the buffer  >  BufRead/BufReadPost > processing modelines > BufWinEnter

        " BufEnter
                " After entering a buffer.
                        " After |BufAdd|.
                        " After |BufReadPost|.
                        "
            Useful for setting  options for a file type.  Also executed when  starting to edit a buffer.


        " BufWinEnter
                " After a buffer is displayed in a window.
                " This  may be when the buffer is loaded (after  processing modelines) or
                " when a hidden buffer  is displayed (and is no longer hidden).
å…ˆè¿›åå‡º:
WinEnter > TabNew > TabEnter	>  BufEnter > TabNewEntered
                                   BufLeave > WinLeave > TabLeave

BufAdd > BUfEnter

BufAdd		 buffer listé‡Œæœ‰æ–°åå­—

BufWritePost > BufUnload > BufDelete
                            buffer listé‡Œå°‘äº†ä¸€ä¸ªåå­—

BufWinLeave	> a buffer is removed from a window.
			  BufUnload, BufHidden.


BufEnter			After entering a buffer.
				After |BufAdd|.
				After |BufReadPost|.

BufFilePost			After changing the name of the current buffer
				with the ":file" or ":saveas" command.

BufFilePre			Before changing the name of the current buffer
				with the ":file" or ":saveas" command.

BufHidden

BufLeave		Before leaving to another buffer.

BufModifiedSet			After the `'modified'` value of a buffer has
				been changed.

							*BufNew*
BufNew			Just after creating a new buffer (æ”¹åä¹Ÿç®— æ–°buffer)

BufNewFile			When starting to edit a file that doesn't  file.

read file into the buffer  >  BufRead/BufReadPost > processing modelines > BufWinEnter


BufReadCmd			Before starting to edit a new buffer.  Should
				read the file into the buffer

BufReadPre > reading the file into the buffer.


" å¥½å¤æ‚, ä¸å®Œå–„, åˆ«æ·±ç©¶:https://vi.stackexchange.com/a/36593/38936

							*BufWipeout*
BufWipeout			Before completely deleting a buffer.  The

BufWrite/BufWritePre	Before writing the whole buffer to a file.

BufWriteCmd			    Before writing the whole buffer to a file(å’Œä¸Šé¢çš„åŒºåˆ«æ˜¯?)

BufWritePost


TermOpen > TermEnter
TermClose > TermLeave

TermOpen			When a |terminal| job is starting.
TermLeave			After leaving |Terminal-mode|.
TermClose			When a |terminal| job ends.


    " æ”¹äº†ä¸ç”Ÿæ•ˆï¼š
        " func! MyTab()
        "     let label = ''
        "     let bufnrlist = tabpagebuflist(v:lnum)
        "                                 " tab page number for 'guitablabel'
        "                                 "
        "     " Add '+' if one of the buffers in the tab page is modified
        "         for bufnr in bufnrlist
        "             if getbufvar(bufnr, "&modified")
        "                 let label = '+'
        "                 break
        "             endif
        "         endfor
        "
        "     if label != ''
        "         let label .= ' '
        "     endif
        "
        "     " Append the buffer name
        "     return label . bufname(bufnrlist[tabpagewinnr(v:lnum) - 1])
        " endfunc

        " set tabline=%!MyTab()
        " ç¬”è®°:
        "
            "     N for number
            "     S for string
            "     F for flags as described below
            "     - not applicable
            "
            " item  meaning ~
            " f S   Path to the file in the buffer, as typed or relative to current  directory.
            " F S   Full path to the file in the buffer.
            " t S   File name (tail) of file in the buffer.
            " m F   Modified flag, text is "[+]"; "[-]" if 'modifiable' is off.
            " M F   Modified flag, text is ",+" or ",-".
            " r F   Readonly flag, text is "[RO]".
            " R F   Readonly flag, text is ",RO".
            " h F   Help buffer flag, text is "[help]".
            " H F   Help buffer flag, text is ",HLP".
            " w F   Preview window flag, text is "[Preview]".
            " W F   Preview window flag, text is ",PRV".
            " y F   Type of file in the buffer, e.g., "[vim]".  See 'filetype'.
            " Y F   Type of file in the buffer, e.g., ",VIM".  See 'filetype'.
            " q S   "[Quickfix List]", "[Location List]" or empty.
            " k S   Value of "b:keymap_name" or 'keymap' when |:lmap| mappings are
            "       being used: "<keymap>"
            " n N   Buffer number.
            " b N   Value of character under cursor.
            " B N   As above, in hexadecimal.
            " o N   Byte number in file of byte under cursor, first byte is 1.
            "       Mnemonic: Offset from start of file (with one added)
            " O N   As above, in hexadecimal.
            " N N   Printer page number.  (Only works in the 'printheader' option.)
            " l N   Line number.
            " L N   Number of lines in buffer.
            " c N   Column number (byte index).
            " v N   Virtual column number (screen column).
            " V N   Virtual column number as -{num}.  Not displayed if equal to 'c'.
            " p N   Percentage through file in lines as in |CTRL-G|.
            " P S   Percentage through file of displayed window.  This is like the
            "       percentage described for 'ruler'.  Always 3 in length, unless
            "       translated.
            " a S   Argument list status as in default title.  ({current} of {max})
            "       Empty if the argument file count is zero or one.
            " { NF  Evaluate expression between '%{' and '}' and substitute result.
            "       Note that there is no '%' before the closing '}'.  The
            "       expression cannot contain a '}' character, call a function to
            "       work around that.  See |stl-%{| below.
            " {% -  This is almost same as { except the result of the expression is
            "       re-evaluated as a statusline format string.  Thus if the
            "       return value of expr contains % items they will get expanded.
            "       The expression can contain the } character, the end of
            "       expression is denoted by %}.

" tabæ ·å¼
func! Tabline()
    let style = ''
    for i in range(tabpagenr('$'))
        let tab = i + 1
        let winnr = tabpagewinnr(tab)
        let buflist = tabpagebuflist(tab)
        let bufnr = buflist[winnr - 1]
        let file_name = bufname(bufnr)
        let bufmodified = getbufvar(bufnr, "&mod")

        let style .= '%' . tab . 'T'
        let style .= (tab == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#')
        let style .= ' ' . tab .'.'
        if  file_name =~ "term:"
                    " =~   regexp matches (zshé‡Œä¹Ÿæ˜¯è¿™æ · ä¸æ˜¯~=, pythoné‡Œç”¨regularæ¨¡å—å§ )
                    " !~   regexp doesn't match
            " echo bufname() æ˜¾ç¤º:
                " term://~/dotF/cfg/nvim//809801:zsh
            let file_name = "<" . bufnr . ">"
        endif
        let style .= (file_name != '' ? ''. fnamemodify(file_name, ':t') . ' ' : 'No Name')

        if bufmodified
            let style .= '[+] '
        endif
    endfor

    let style .= '%#TabLineFill#'
    return style
endfunc

hi TabLineFill  guibg=#e0e5e3  guifg=#123456
hi TabLineSel   guibg=#e0f6e3  guifg=#123456
hi TabLine      guibg=#e0e5e3  guifg=#123456


æ²¡ç”¨çš„è®¾ç½®?
    func Map_n_()
        if  bufname() == "[Command Line]"
            exe 'normal  *'
                " è¿˜æ˜¯ä¸åƒä¸€èˆ¬bufferé‡Œçš„searchä¸‹ä¸€ä¸ª, å‡‘åˆç€ç”¨å§, command line  windowä¸æ˜¯ä¸€èˆ¬çš„normal mode
                " ä¸è¡Œ
        else
            exe 'normal \<Plug>(anzu-mode-n)'
            " exe 'normal! <Plug>(is-nohl-3)<Plug>(anzu-mode-n)'
            " exe 'normal! <Plug>(is-nohl-3)<Plug>(anzu-sharp-with-echo)'
                        " æ•²äº†3æ¬¡n/Nåå–æ¶ˆé«˜äº®
        endif
    endfunc

    func Map_N_()
        if  bufname() == "[Command Line]"
            exe 'normal  #'
        else
            exe 'normal \<Plug>(anzu-mode-N)'
        endif
    endfunc

    nn n :call Map_N_()<cr>
    nn N :call Map_N_()<cr>

        " æ•²äº†3æ¬¡n/Nåå–æ¶ˆé«˜äº®
            " nmap n <Plug>(is-nohl-3)<Plug>(anzu-mode-n)
            " nmap N <Plug>(is-nohl-3)<Plug>(anzu-mode-N)
                " anzu-modeå¯¼è‡´å¾ˆæ…¢, è€Œä¸”å¼„è„ä»£ç 
            " nmap n <Plug>(anzu-n-with-echo)
            " nmap N <Plug>(anzu-N-with-echo)




    func Search_no_comment()
        if &filetype == 'vim'
            exe 'normal msgg/\v^[^"]*'
        elseif expand('%:t') == 'init.vim'
            exe 'normal msgg/\v^[^"]*'
            " é˜²æ­¢æ£€æµ‹filetypeä¸å‡†
        elseif &filetype == 'autohotkey'
            " vimçš„æŸä¸ªæ–‡ä»¶å·²ç»è®¾ç½®äº†:  au BufNewFile,BufRead *.ahk  setf autohotkey
            exe 'normal msgg/\v^[^;]*'
            " todo è£…ä¸ªæ’ä»¶
            " https://github.com/hnamikaw/vim-autohotkey
        elseif index(['zsh', 'sh', 'python'], a:item) >= 0
            " https://vi.stackexchange.com/a/29471/38936
            exe 'normal msgg/\v^[^#]*'
        elseif expand('%:t') == 'tmux.conf'
            exe 'normal msgg/\v^[^#]*'
        elseif index(['json', 'jsonc', 'cpp'], a:item) >= 0
            exe 'normal msgg/\v^[^(//)]*'
        else
            exe 'normal msgg/\v^[^#";]*'
                " vscode neovimæ— æ³•è¯†åˆ«filetype?
                " æš‚æ—¶ä¸€é”…ä¹±ç‚–
        endif
let s:_rhs = "normal" . "msgg/\v^[^"  .
        exe _rhs
    endfunc

        nnoremap ? :call Search_no_comment()<cr>




" vimçœ¼ä¸­çš„ä¸€ä¸ªword
    " æˆ‘çš„ç¬”è®° https://github.com/vim/vim/issues/576
    " https://vi.stackexchange.com/a/36657/38936

    " å…ˆè§£å‡ ç§å¸¸è§character classes
        " Those also work for multibyte characters:
                " \k	keyword character (see 'iskeyword' option)
                " \K	like "\k", but excluding digits

                " \w	word character:			[0-9A-Za-z_]
                " \W	non-word character:		[^0-9A-Za-z_]	 (æœç´¢æ—¶  å¯ä»¥åŒ¹é…ä¸­æ–‡ç­‰non asciiå­—ç¬¦)
                                                                  å¤šä¸ªnon-word characterå¯ä»¥æ„æˆä¸€ä¸ªword!!!!


        " An empty line  is also considered to be a word/WORD
        "
        " A sequence of folded lines is counted as   one word of a single character.
        "
        " todo:
                " "w" and "W", "e" and "E" move to the start/end of the first word or WORD after a range of folded lines.
                "
                " "b" and "B" move to the start of the first word or  WORD before the fold.



    " 'iskeyword' 'isk'	string (default: @,48-57,_,192-255 )  128åˆ°255æ˜¯extended  ascii, å¤§éƒ¨åˆ†æ˜¯è¥¿æ–‡å­—æ¯, æˆ‘ä»¬ç”¨ä¸ä¸Š
    "                                      å¯¹åº”æ•°å­—0åˆ°9
        "    local to buffer

        "    ä¼šå½±å“å‘½ä»¤a :K
                    " [count]K
                    "     Runs the program given by 'keywordprg' to lookup the
                    "     |word| (defined by 'iskeyword') under or right of the
                    "     cursor.
                    "
                    "     æˆ‘ç°åœ¨:    keywordprg=:help

        "     Keywords are used in searching and recognizing with many commands:
        "           "w",
        "           "*",
        "           "[i",
        "           "\k" in a |pattern|.(æœ\kèƒ½åŒ¹é…ä¸­æ–‡)
        "
        "     Q:æ²¡æ˜ç™½ keywordå¦‚ä½•å®šä¹‰word,  wordä¸å°±æ˜¯ç”±word character [0-9A-Za-z] ç»„æˆçš„å—?
        "     A: éä¹Ÿ, set iskeyword+=- ä»¥å, peco-findå°±æ˜¯ä¸€ä¸ªword,  ä½†è¿å­—ç¬¦ä¸å±äºword character
        "
        "
        "     See  'isfname' for a description of the format of this option.
        "
                    " The format of this option is a list of parts, separated with commas.
                    " Each part can be a single character number or a range.  A range is two
                    " character numbers with '-' in between.  A character number can be a
                    " decimal number between 0 and 255 or the ASCII character itself (does
                    " not work for digits).  Example:
                    "     "_,-,128-140,#-43"	(include '_' and '-' and the range
                    "                 128 to 140 and '#' to 43)
        "     å¦‚æœåŠ äº†'@':
        "         characters above 255å°†ä¼š:
            "        check (å…¶å®æ˜¯æƒ³è¡¨è¾¾fall back to ?) the "word"  character class
            "                   (å½“ä½œ"word"  character ?)
            "        ä¹Ÿå°±æ˜¯:any character  that is not white space or punctuation, )
            "     æƒ³æŠŠä¸­æ–‡æ”¾è¿›'iskeyword? æš‚æ—¶ä¸è¡Œ: https://github.com/vim/vim/issues/576
            "

        "     This option also influences syntax highlighting,
        "            unless the syntax  uses |:syn-iskeyword|.

                    " It is recommended when writing syntax files, to use this command to
                    " set the correct value for the specific syntax language and not change
                    " the 'iskeyword' option.
                    "
                    "

if exists('$TMUX')
    au BufReadPost,FileReadPost,BufNewFile * call system("tmux rename-window " . expand("%"))
    au VimLeave * call system("tmux rename-window zsh")
    " au BufEnter,FocusGained * call system("tmux rename-window " . expand("%:t"))
    " au BufEnter * let &titlestring = ' ' . expand("%:t")
    set title
endif

    "  å¿«é€ŸæŸ¥map
            func! KeymaP(keys)
                exe "verbose map "  . a:keys
                exe "verbose map! " . a:keys
                exe "verbose tmap " . a:keys


                " ä¸å¥½: (æ²¡æœ‰ä¸Šé¢çš„é‚£ä¹ˆæ™ºèƒ½)
                    " exe "verbose nmap " . a:keys
                    " exe "verbose omap " . a:keys
                    " exe "verbose vmap " . a:keys
                    " exe "verbose imap " . a:keys
                    " exe "verbose cmap " . a:keys
                    " exe "verbose tmap " . a:keys
                " ä¸è¡Œ
                    " exe "Verbose map " . a:keys  . <Bar> . "verbose map! " . a:keys . <Bar> .  "verbose tmap " . a:keys
            endf


substituteå, gvæœ‰æ—¶æ— æ³•é€‰ä¸­ä¹‹å‰çš„å†…å®¹
        " normal! gv
        " subs #or\zs #\r#ge
        " normal! gvj
        " subs #and\zs #\r#ge
        " normal! gvj
        " subs #exmaple\zs #\r#ge





let g:head_of_split =  '('
    " 1.æ ‡ç‚¹ç¬¦å·
    let g:head_of_split .=  '('
        let g:head_of_split .=  '(' .. '<\k+>' .. '["|'']'  .. ')'
                                                    " å•å¼•å·é‡Œé¢è¦ç”¨å•å¼•å·, å¿…é¡»å¤šå†™ä¸€ä¸ª
                                                    " åŠ è¿™è¡Œ, é¿å…æ ‡ç‚¹ç¬¦å·å•ç‹¬æˆè¡Œ?
        let g:head_of_split .=  '[,;!.?:]'
                             "  å¯å°è¯•[[:punct:]]
                                          " ä¸­æ‹¬å·åŒ…è£¹ ğŸ’¦:help /collectionğŸ’¦
                                          "            ğŸ’¦:help character-classesğŸ’¦
                                          " é‡Œé¢çš„backslashçš„escapeå’Œä¸­æ‹¬å·å¤–ä¸åŒ:
                                                " \e      <Esc>
                                                " \t      <Tab>
                                                " \r      <CR>    (NOT end-of-line!)
                                                " \b      <BS>
                                                " \n      line break, see above |/[\n]|
                                                "
                                                " \d123   decimal number of character
                                                " \o40    octal number of character up to 0o377
                                                " \x20    hexadecimal number of character up to 0xff
                                                "
                                                " \u20AC  hex. number of multibyte character up to 0xffff
                                                " \U1234  hex. number of multibyte character up to 0xffffffff
        " let g:head_of_split .=  '[.!?][])"]*($|[ ])'
                                 " [])"]: è¿™å‡ ä¸ªä¸­çš„ä»»æ„ä¸€ä¸ª:
                                 "         ] ğŸ’›å®ƒä¸€å®šè¦ç´§è·Ÿæœ€å‰é¢çš„[ğŸ’›
                                 "         "
                                 "         )

                        " æ¥è‡ª:  /home/linuxbrew/.linuxbrew/Cellar/neovim/0.6.1/share/nvim/runtime/doc/pattern.txt
                        " A search pattern that finds the end of a sentence,
                        " with almost the same definition as the ")" command.

                        " æˆå¯¹å•å¼•å·é‡Œé¢ç”¨å•å¼•å·, ç”¨æ•²2ä¸ªå•å¼•å·?
                        " let g:head_of_split .=  '[.!?][])"'']*($|[ ])'
                    "
                    " <\k+>å¤„ç† : I am before a æ ‡ç‚¹ç¬¦å·.
                            " åŒå¼•å·å¤„ç†: I am before a "æ ‡ç‚¹ç¬¦å·".
    let g:head_of_split .=  ')'
    let g:head_of_split .=  '|'

    " 2. å¸¸è§åˆ’åˆ†æ„ç¾¤çš„è¯
    " let g:head_of_split .=  '('
        " é¿å… è¿™ç§æƒ…å†µä¸‹ä¼šåˆ‡å¾—å¾ˆç¢: a word, which
    let g:head_of_split .=  '\w ('
        let g:head_of_split .=  '<or>|'
        let g:head_of_split .=  ' <which>|'
        let g:head_of_split .=  '<and>|'
        let g:head_of_split .=  '<so that>|'
        let g:head_of_split .=  '<by>|'
                                 " å¦‚ä½•æ’é™¤<by default> ?
        let g:head_of_split .=  '<or not>|'
        let g:head_of_split .=  '<is composed of>|'
        let g:head_of_split .=  '<of this is that>|'
        let g:head_of_split .=  '<evaluated to>|'
        let g:head_of_split .=  'there are cases where|'
        let g:head_of_split .=  'example'
    let g:head_of_split .=  ')'
let g:head_of_split .=  ')'

let  g:end_of_split =  g:head_of_split

" let g:split_me =  '\v' .. g:head_of_split ..  '\zs' .. ' ' .. '\ze' .. '.{5,}' ..  g:end_of_split  å¯¼è‡´æ–­å¥çš„åœ°æ–¹å¤ªå°‘
let g:split_me =  '\v' .. g:head_of_split ..  '\zs' .. ' ' .. '\ze' .. '.{5,}'

        " subs |\t| |ge    "  å¯¼è‡´å‡ºé”™ (perlé‡Œé¢å¯ä»¥ç”¨ç«–çº¿ä½œä¸ºdelimeter?)
                           " You can use most characters, but not an alphanumeric character, '\', '"' or  '|'.



    " hi CursorLine guibg=rice_white_wf gui=undercurl
    " syn match underscore "_"
    " hi underscore gui=reverse
    "
        " au BufRead * if !exists('g:ReloadinG')  | set foldenable foldmethod=indent   | normal! zM  | let b:folded = 1  | endif
                                    " :normal
                                    " This command cannot be followed by another command, ä¸èƒ½ç”¨bar

" å…³äºç©ºæ ¼ ç©ºç™½ç¬¦
"  [:graph:]   isgraph   ASCII printable characters excluding  space
" [:space:]      [:space:]         whitespace characters: space, tab, CR,
"                                 NL, vertical tab, form feed
" |/\s|    \s    \s    whitespace character: <Space> and <Tab>
" \r    matches <CR>
" \b    matches <BS>
" \n    matches an end-of-line




        " formatexpr: local to buffer
        " æ‰€ä»¥ä¿®æ”¹init.vimç­‰æ–‡ä»¶ ä¿å­˜å¹¶reloadå, å…¶ä»–æ­£åœ¨ç¼–è¾‘çš„æ–‡ä»¶çš„formatexprä¸å˜, è¦åœ¨é‚£ä¸ªæ–‡ä»¶é‡Œreloadä¸€æ¬¡
        " ä½† One_sentence_per_lineæ”¹äº†å, å…¶ä»–æ­£åœ¨ç¼–è¾‘çš„æ–‡ä»¶ èƒ½é©¬ä¸Šæ„Ÿå—åˆ°,ä¸ç”¨reload
        "
        "
        "

        nnor <silent> <M-p> vipJ:silent! call Split_line()<cr>vip
                                silentæ²¡ç”¨, è¦åŠ e:  sub #æŸæŸ#æŸæŸæŸ#ge


        "  æ•²ssæƒ³é€€å‡ºæ–‡ä»¶æ—¶, ä¼šè§¦å‘è¿™ä¸ªautocmd, å…ˆåˆ«åŠ startinsert
                                                                " è¿™äº›éƒ½ä¸è¡Œ:
        " au BufWritePost ~/dotF/cfg/nvim/*.vim  call ReloaD() | startinsert!
        " au BufWritePost ~/dotF/cfg/nvim/*.vim  call ReloaD() | startinsert | stopinsert
        " au BufWritePost ~/dotF/cfg/nvim/*.vim  call ReloaD() | startinsert! | normal! b


"å…³äºftplugin
    " au AG BufEnter * if &ft == 'help' | call Help_opts() | endif
    " au AG BufRead  * if &ft == 'help' | call Help_opts() |  echom 'bufRead' . &ft .'  bufnumæ˜¯' . bufnr() | endif
    " au AG BufAdd  *  if &ft == 'help' | call Help_opts() |  echom 'bufAdd ____________ ' . &ft .'  bufnumæ˜¯' . bufnr() | endif
                   " å¦‚æœftæ²¡å˜, autocmdä¼šè¢«å°±çš„&ftè¯¯å¯¼?
                                                        " ä¸ºå•¥ftpluginé‡Œæ²¡ç”Ÿæ•ˆ?
                                                        " åº”è¯¥ä¸æ˜¯æ²¡ç”Ÿæ•ˆ, è€Œæ˜¯æ²¡è¿›å…¥helpè¿™ç±»filetype
    " todo
    " è¯•ä¸€ä¸‹è¿™æ ·?
    " au AG BufAdd  *.txt  if &ft == 'help' | call Help_opts() |  echom 'bufAdd ____________ ' . &ft .'  bufnumæ˜¯' . bufnr() | endif


" manå’Œhelpç­‰bufferå…¬ç”¨
    func! g:TOC_leo()
        wincmd L
        vertical resize -20
        set modifiable
        exec 'normal! ggVGgu'
                    " å…¨éƒ¨å°å†™
        silent % subs #\.\s*\w#\=toupper(submatch(0))#ge
        "                                       " e: æ²¡é…å¯¹åˆ°æ—¶ ä¸æŠ¥error
        "   "\=toupper(submatch(0)) ç­‰ä»·äºå®ƒ?        \U&#g
        silent % subs #\(^\|\s\s\+\)\w#\=toupper(submatch(0))#ge
         " æ›´å¤šsubsçš„ä¾‹å­
         " : s/^/\=  line(".") .  ". "                 /g
         "       \=åçš„ä½œä¸ºä¸€ä¸ªexpr, å¤§éƒ¨åˆ†ç©ºæ ¼æ˜¯å¤šä½™çš„
         "     submatch(0): åŒ¹é…åˆ°çš„æ‰€æœ‰å¯¹è±¡
        silent % subs #\*##ge
        silent %retab | set expandtab
        " silent % subs #\*\zs\w\+\ze\*#=submatch(0)#ge
        " æ‰”æ‰vimçš„Tocçš„æ˜Ÿå·
    endf





split / one_sentence_per_line
        " let g:split_after =  '\v' .. g:stop_after ..  '\zs' .. ' ' .. '\ze' .. '.{5,}' ..  g:end_of_split
                                                                                            " å¯¼è‡´æ–­å¥çš„åœ°æ–¹å¤ªå°‘
                                                                                           " todo: å¦‚ä½•é™åˆ¶é…å¯¹åˆ°çš„patternéš”å¼€ä¸€å®šè·ç¦»?
        " let g:split_after =  '\v' .. g:stop_after ..  '\zs' .. ' ' .. '\ze' .. '.{2,}'   å¯¼è‡´æ–­å¾—å¤ªç¢, æ¯”å¦‚: by defaultè¢«æ–­å¼€
        " let g:split_after =  '\v' .. g:stop_after ..  '\zs' .. ' ' .. '\ze' .. '.{9,}'
                                                                                    " è¿™é‡Œ\zeçœ‹åˆ°çš„æ˜¯æ–­å¥å‰çš„, æ‰€ä»¥æ–­å¥å æ–­å¥å¤„è¿˜æ˜¯åªå‰©å¾ˆå°‘å­—ç¬¦
                                                                                    " å¦‚ä½•æ¯é€‰ä¸­ä¸€æ¬¡æ–‡æœ¬, åªæ–­ä¸€æ¬¡, ä¸‹æ¬¡é‡æ–°é€‰ä¸­æœªå¤„ç†çš„?
å¾…ç¿»é˜…:                                                                                    "
func! ReloaD()
        " mapclear  | mapclear <buffer>
                " å¯¼è‡´easymotionçš„mapç”¨ä¸äº†  leaderFç­‰çš„mapè¿˜åœ¨
        " mapclear! | mapclear! <buffer>
            " ä¼šæŠŠæ’ä»¶é‡Œçš„mapä¹Ÿæ¸…æ‰  è¿™è¡Œå¯¼è‡´cocå‡ºbug
            " https://stackoverflow.com/questions/21945038/resetting-all-key-maps-in-vim

        " todo: å¦‚ä½•åªæ¸…ç†æˆ‘å®šä¹‰çš„autocmdå’Œmap ä»¥åŠfunc ?
        "
            " è¿™å †: å¯¼è‡´reloadå å¾ˆå¤šmapæ— æ³•ä½¿ç”¨.
            " å› ä¸ºzshä¸‹æ•²nvim å¯åŠ¨æ—¶, è¯»å®Œinit.vim, è¿˜è¦è¯»runtimepathä¸‹çš„æ–‡ä»¶ç­‰
                    " mapclear
                        " Clear previous mappings, they don't go away automatically when sourcing vimrc

                    " mapclearæ¸…ç†normal visual operation modeçš„
                    " mapclear!æ¸…ç†insert\ command mode
                    " mapclear | mapclear <buffer> | mapclear! | mapclear! <buffer> | au!
                        " ä¼šå¯¼è‡´Cocrefreshå•¥çš„ä¸è¡Œ (è¦åœ¨source init.vimå‰æ¸…ç†æ‰?)
                        " åº”è¯¥æ˜¯au! æ¸…æ‰äº†æ’ä»¶çš„autocmd

            " function!  è¿™ä¸ªä¸æ˜¯æ¸…é™¤æ‰€æœ‰å‡½æ•°
            " delfunction Your_function_name
                " delfunction .*  " ä¸èƒ½é€šé…?
        " echo 'é‡æ–°åŠ è½½init.vim, è®°å¾—æ‰‹åŠ¨ä¿å­˜å…¶ä»– ä¿®æ”¹è¿‡çš„initç³»åˆ—çš„æ–‡ä»¶, ä¸ç„¶æ–°é…ç½®æ— æ³•ç”Ÿæ•ˆ'

        "
        "è¿™è¡Œçš„å­˜åœ¨ ä¼šå¯¼è‡´å¾ˆå¤šé—®é¢˜
            " au AG SourceCmd  * echom 'source Cmd'
            "
            " Most of the time ColorScheme event is the only one actually used event
            " that may be launched on resourcing vimrc
               " (SourcePre and  SourceCmd are also omitted without nesting,
                " but I almost never see them used;
                " except for SourceCmd commands for {proto}:// pseudo-protocols and
                " (possibly compressed) vimball files).

        " let g:do_not_change_fold = 'reloading, do not change fold'
              " æš‚æ—¶æ²¡ç”¨ä¸Š

        " todo: å¦‚ä½•æ¸…ç†æ‰æ‰€æœ‰çš„b:var ?
        " æ¸…æ‰å è¿˜èƒ½ç”¨æ’ä»¶?
        " unlet b:
        " unlet g:
        messages clear
        source $MYVIMRC
        lua require('my_cfg')
        set nohlsearch
        " source <sfile>
                " åœ¨scripté‡Œ, <sfile>ä¼šexpandä¸ºæœ¬æ–‡ä»¶
                " ä½†ç°åœ¨æ˜¯åœ¨å‡½æ•°é‡Œ,    expandä¸ºğŸ’¦function ReloaDğŸ’¦
                    " || Error detected while processing function
                    " init.vim|56| ReloaD[23]
                    " || E484: Can't open file function ReloaD

            " todo: åªsourceæ”¹è¿‡çš„æ–‡ä»¶?
            " æœ‰æ—¶å‡ºç°: reloadæ—¶æ²¡æŠ¥é”™çš„åœ°æ–¹, åœ¨é‡å¯nvimæ—¶æŠ¥é”™ (reloadæ—¶æŠ¥é”™äº†,åªæ˜¯æˆ‘æ²¡çœ‹åˆ°? æˆ–è€…reloadæ—¶é‡åˆ°é”™è¯¯å°±è·³è¿‡?)
        redraw!
        source /home/wf/dotF/cfg/nvim/autoload/man.vim
        " unlet g:do_not_change_fold
    endf


au AG BufWritePost
    \ ~/dotF/cfg/nvim/coc-settings.json
    \ ++nested
    \ CocRestart

    " æ—§çš„reloadç³»åˆ—:
        " \  call ReloaD() | startinsert | stopinsert
                            " åŠ¨ä¸€ä¸‹å…‰æ ‡, å±•å¼€æŠ˜å 

        " resourcing vimrcæ—¶, è¦åŠ nested
        " https://github.com/powerline/powerline/commit/5173246a939f1a665d1908c536be6f04e6717ef1

        " au AG BufWritePost ~/dotF/cfg/nvim/*.vim  call ReloaD() | delfunction Reload | stopinsert
                                                  " å¯¼è‡´:
                                                  "  Error detected while processing BufWritePost Autocommands for "/home/wf/dotF/cfg/nvim/*.vim":
                                                  "  E130: Unknown function: Reload

        " au AG BufWritePost ~/dotF/cfg/nvim/*.vim  if &buftype == 'terminal' |  setlocal statusline=%9*-\ -\  | endif
                                                " ä¸è¡Œ....statuslineåº”è¯¥åœ¨è¯»init.vimå‰ç¡®å®šçš„

            " ä¸ç”Ÿæ•ˆ
            " When resourcing vimrc: always use autocmd-nested  å› ä¸ºauæ‰§è¡Œæ—¶ ä¼šåˆé‡åˆ°au

    " au AG BufWritePost
    "     \ *.vim,*.lua
    "       "\ ä¸¤ä¸ªæ–‡ä»¶patternä¹‹é—´ä¸èƒ½æœ‰ç©ºæ ¼:
    "     \ ++nested
    "     \ Runtime

            " Runtime : å¦‚æœå½“å‰æ–‡ä»¶ä½äº'runtime', unlet g:loaded_æŸæŸå sourceå®ƒ
            " ç„¶åcall ReloaD(),  ä¼šsourceæ²¡æ”¹çš„æ–‡ä»¶,å¯¼è‡´æ…¢


" ç©ºæ ¼/ tab
    " nnore <silent> ts :call T2F()<CR>
    "     func! T2F()  " tab to space
    "         " echom 'åœ¨visual modeç”¨æ—¶, ç¼©è¿›æ•°ä¼¼ä¹ä¸é€‰ä¸­è¡Œæ•°æˆæŒ‡æ•°å…³ç³», è¶…å‡ºå±å¹•èŒƒå›´ä¼šå¡æ­»'
    "
    "         set expandtab
    "         retab! 4
    "         echom "Tabå˜æˆ4ç©ºæ ¼"
    "
    "         " todo:
    "             " exec '% subs#' .. '\v^\s*\zs\t' .. '#    #ge'
    "             " echom "ç”¨:substitute  æŠŠé™¤äº†æ–‡å­—å¤¹ç€çš„tab ä»¥å¤–çš„tab å˜æˆ4ç©ºæ ¼"
    "     endf
    "
    "     " au AG BufRead *.py  exe ":call T2F()"
    "     " autocmdå¯¹neovim-vscodeæ— æ•ˆï¼Ÿ
    "
    "     " éœ€è¦æ—¶å†æ‰‹åŠ¨æ•², ä¸ç„¶å°±ç®—æ²¡å®è´¨æ”¹åŠ¨æ—¶ ä¹Ÿè®°å…¥undo history
    "
    "
    " nnore <silent> tf :call D2F()<CR>
    "              " ts:tab to space
    "              " tf:double to four
    "
    "     func! D2F()
    "         " Double to Four
    "         " 'åœ¨visual modeç”¨æ—¶, ç¼©è¿›æ•°ä¼¼ä¹ä¸é€‰ä¸­è¡Œæ•°æˆæŒ‡æ•°å…³ç³», è¶…å‡ºå±å¹•èŒƒå›´ä¼šå¡æ­»'
    "
    "         set noexpandtab
    "         retab! 2
    "         " å®¹æ˜“å¯¼è‡´ä¸­é—´çš„ç©ºç™½å¯¹ä¸é½
    "
    "         call T2F()
    "         endf
    "
    " func! F2T()
    "     echom "4ä¸ªç©ºæ ¼ å˜æˆtab"
    "     set noexpandtab  tabstop=4
    "     %retab!
    " endf
    "
    " " nno <F10> :call Indent_wf()<CR>
    " " ino <F10> <ESC>:call Indent_wf()<CR>i






    "        echo Very_magiC('\m-hi.*\<lucy\>' )
    "  å»æ‰å¼€å¤´çš„\v-
    "        echo Very_magiC('\m-\(hi.*lucy\)' )[3:]
    "        echo Very_magiC('\m-' .. expand('<cword>')  )[3:]
    "        echo Very_magiC('\m-' .. @" ) [3:]
    "     vnor <leader>r y:let @" = '/v' .. Very_magiC('v', '\m-' .. @" )[4:]<cr><esc>:echom @"<cr>
    "     vnor <leader>r y:let @" =  Very_magiC('\m-' .. @" )[4:]<cr><esc>:echom @"<cr>


/home/wf/dotF/cfg/nvim/clipboard_regis.vim
            "é‡åˆ°å¾ˆå¤šé—®é¢˜:
                " 1. èƒ½ç²˜è´´åˆ°æœ¬åœ°, ä½†:registeré‡Œæ— æ³•æ˜¾ç¤ºåŠ å·å’Œæ˜Ÿå·å¯„å­˜å™¨. ä¸èƒ½æ—¢ä¼ åˆ°æœ¬åœ°, åˆå­˜åœ¨vim?
                " 3. dittoæ˜æ˜ç¦æ­¢äº†windows terminal, ä½†æœ‰æ—¶è¿˜æ˜¯èƒ½å¤åˆ¶è¿›å»
                " 4. :registeræ˜¾ç¤º*å¯„å­˜å™¨æœ‰å†…å®¹, ä½†æ— æ³•<ctrl-r>ç²˜è´´åˆ°vim (æ­¤æ—¶æ•²:register +  ä¸æ˜¾ç¤ºåŠ å·å¯„å­˜å™¨, :register *  åˆæ²¡æœ‰å†…å®¹)
                " `<c-r> +`å, èƒ½æ’å…¥å†…å®¹, å†æ¬¡æ“ä½œ, åˆ™ä¸è¡Œ
            " let g:clipboard = {
            "     \   'name': 'myClipboard',
            "     \   'copy': {
            "     \      '+': 'xclip -selection clipboard -in -silent -loops 2',
            "     \      '*': 'xclip -selection clipboard -in -silent -loops 2',
            "     \    },
            "     \   'paste': {
            "     \      '+': 'xclip -selection clipboard -out',
            "     \      '*': 'xclip -selection clipboard -out',
            "     \   },
            "     \   'cache_enabled': 1,
            "     \ }

            " æ”¾å¼ƒäº†, è¿˜æ˜¯ç”¨é¼ æ ‡é€‰ä¸­å§
            " dittoé‡Œ, ctrl tabç²˜è´´ä¸€æ¬¡å, ç²˜è´´æ¿çš„å†…å®¹å°±å¤±è¸ªäº†.
            " windowsç²˜è´´æ¿é‡Œctrl v, åŒç†

            " æ”¹äº†vimé…ç½®, è¦é‡å¼€VcXsr æ‰ç”Ÿæ•ˆ
            " æ›´æ–°: windowsç²˜è´´æ¿é‡Œctrl v, åˆå¯ä»¥æ— é™ç²˜è´´äº†... å› ä¸ºå¼€äº†  'cache_enabled': 1  ?
      "       Or å› ä¸ºå®ƒ?
          "       set clipboard=unnamedplus
          "
          "   ä¸çŸ¥é“ä»€ä¹ˆæ—¶å€™è®°çš„:
            " æœ‰æ—¶æŠ¥é”™ can not open displayå•¥çš„. æœ‰æ—¶åˆæ­£å¸¸, å“ªæ€•åœ¨ç”¨windows terminal, ä¸”æ²¡å¼€xming'
    " au AG BufEnter  term://*   normal! iechom 'hi'
    "       " æ¯æ¬¡è¿›terminaléƒ½æ–°å¼€ä¸€ä¸ªzsh? å¤±è´¥äº†, è€Œä¸”æœ‰ç‚¹ç–¯ç‹‚, ç®—äº†
    " BufAdd ä¼šå¯¼è‡´æ–°å¼€terminalæ—¶, å½±å“å…¶ä»–buffer? å…ˆæ‰”æ‰
    " ä¸€å®šè¦ç¦»å¼€terminalå†è¿›å…¥,æ‰ç”Ÿæ•ˆ, åŠ äº†BufNewFile,BufReadPost,BufNewéƒ½ä¸è¡Œ
    "  abdåˆšè¿›å…¥nvimæ—¶(è¿›å…¥terminal mode), è¿™ä¸ªauä¸ç”Ÿæ•ˆ
    "  è§£å†³: è¿™é‡ŒåŠ ä¸€å † -c ä»£æ›¿æ— æ³•å®ç°çš„au
            "  abduco -A ${1:-s_wf} nvim -c 'terminal' -c 'startinsert'


                " syn match In_Double_quotE   contains=Double_quotE          '\v^\s*[^:]{-}\zs"[^"]{1,40}"'
                                                                                      " æ’é™¤æ‰å†’å·å¼€å¤´çš„, é¿å…é«˜äº®å‘½ä»¤é‡Œçš„string
                        " syn match In_Double_quotE   contains=Double_quotE    '\v"[-_a-zA-Z0-9'"*+/:%#=[\]<>.,]+"'
                        " syn match In_Double_quotE   contains=Double_quotE    '"\v[^(  )"]{2,60}"' æƒ³æ’é™¤è¿ç»­2ä¸ªç©ºæ ¼
                        " syn match In_Double_quotE   contains=Double_quotE    '"\v[^(  )(:echo )"]{6,60}"'
                                                                                        " æƒ³æ’é™¤æ‰å‘½ä»¤é‡Œçš„string, ä½†ç”¨é”™äº†, collectioné‡Œçš„group
                                                                                        " ä¸æ˜¯è¿™ä¹ˆè¡¨ç¤ºçš„
                                                                                        " ä½†è¿ç»­2ä¸ªç©ºæ ¼å¯ä»¥è¿™ä¹ˆè¡¨ç¤º?

    " toggle virtualedit:  å…¶å®ä¸ç”¨toggle? ä¸€ç›´æŒ‰ä¸Šé¢é‚£è¡Œè®¾å°±è¡Œ? å…ˆæ”¾ç€å§
        " let s:ve_all = 0
        " func! Virtual_edit()
        "     if s:ve_all == 0
        "         " set virtualedit=insert,block
        "         set virtualedit=all
        "         set virtualedit?
        "         let s:ve_all = 1
        "     else
        "         set virtualedit=insert,block
        "         set virtualedit?
        "         let s:ve_all = 0
        "     endif
        " endf
        " nno <Leader>ve :call Virtual_edit()<cr>
            " let s:allå¦ = 0   ä¸èƒ½ç”¨ä¸­æ–‡
            " func! Virtualæˆ‘edit()
            " func! å…‰æ ‡ä»»æˆ‘è¡Œ()  " å‡½æ•°åä¸èƒ½ç”¨ä¸­æ–‡

    fun! To_term_old() abort
            let jid = getbufvar(bid, '__terminal_jid__', -1)

            let g:buf_before_TerM = expand('%:p')
            let workdir = (expand('%') == '')?  getcwd() : expand('%:p:h')
            let @t =  'cd '..fnameescape(workdir)

            if exists('g:term_namE')
                let g:term_buF_bk = g:term_namE
                exe "-tab drop" g:term_namE

            elseif  exists('g:term_buF_bk')
                exe "-tab drop" g:term_buF_bk
            el

                let g:term_job_iD = termopen(
                                      \ &shell,
                                      \ {
                                         \ 'cwd' : '/tmp',
                                         "\ \ 'cwd' : getcwd(),
                                         \ 'on_stdout' : function('s:On_stdouT'),
                                       \},
                                    \ )
                " terminal
            en
                                " ä¸€èˆ¬æƒ…å†µ linuxä¸‹ä¸ç”¨fnameescapeä¹Ÿæ²¡äº‹å§
    endf


verbosefileæ— æ³•è¯»å–?
    "\ nno <Leader>oo  <cmd>call Syn_stacK()<cr>
    "\ å¤±è´¥,å¾…ç»­
    "\ nno <Leader>oo  <cmd>call Tmp_creatE()<cr>
                   "\ \<cmd>call Syn_stack_herE()<cr>
    fun! Syn_stacK()
        call Tmp_creatE()
        call Syn_stack_herE()
    endf

        fun! Tmp_creatE()
            let s:f_tmp   = tempname() . '.vim'
            "\ âœ—ä¸åŠ è¿™è¡Œ æ–‡ä»¶å¯èƒ½ä¸å­˜åœ¨:âœ—
            "\ éä¹Ÿ
            call writefile(
                      \['asdfasdf' ],
                      \s:f_tmp,
                      \'',
                  \  )
        endf

        func! Syn_stack_herE()
            let g_name = []
            for id in synstack( line("."), col(".") )
                call add( g_name, synIDattr( id, "name" ) )
            endfor
            if len(g_name) > 0
                "\ let ver_file     = &verbosefile
                "\ let s:f_tmp   = '/tmp/leo_nvim_tmp.txt'
                "\ let &verbosefile = string(s:f_tmp)
                for _name in g_name
                   Verbose exe 'syn list' _name
                endfor

                "\ silent! let &verbosefile = string(ver_file)
                        "\ \ 'pedit ' . s:f_tmp . '|wincmd P'
            el
                echo 'æ²¡é«˜äº®'
            en
        exe 'split' s:f_tmp
        endf


                    "\ exe
                    "\     \ 'Verbose hi' _name
                    "\                 \ ' | echo "\n\n"
                    "\                   \ | syntax list'  _name
                    "\ exe   'call funcS#VerBosE syntax list'  _name
                    "\ let @a = eval( 'syntax list ' .  _name)
                                    "\ \ '| echo "\n\n"'
                                    "\ \ '| hi' _name

                    " exe 'Verbose syntax list ' _name
        exe 'split' s:f_tmp

                " nnor <leader>f <Cmd>call Lf_cwD('')<cr>:-tab <C-R>=printf("Rg" )<CR><CR>
                                                        " åŠ äº†-ä¸ç”Ÿæ•ˆ

    "\ let g:split_them =  '\v' . Split_After . '|' . Split_In . '|' . Split_Before
        "\ let g:split_them =   Split_After . '|' . Split_In . '|' . Split_Before
        " let g:split_them =   Split_After . '|(' . Split_In . ')' . '|(' . Split_Before . ')'
                                        " å¤šåŠ äº†Â¿()Â¿

    "\ let g:split_them .= '|' . Split_Sbj . '|' . Split_CJK


"\ " ä¹‹å‰çš„è ¢æ–¹æ³•
        "\     " nno  ,c "cy<esc>:syn match ConCeaL "<c-r><c-w>" conceal
        "\     "                     \ containedin=vimLineComment,vimComment
        "\     "                     \<left><left><left><left><left><left><left><left><left><left>
        "\
        "\ " éšè—å è€æ˜¯æƒ³æŒ‰u, æ‰€ä»¥:
        "\     nno  ,u :call matchdelete(a_id)<cr>
        "\     nno  ,U :call clearmatches()<cr>
        "\ " éšè—å è€æ˜¯æƒ³æŒ‰ctrl r, æ‰€ä»¥:
        "\     nno  ,r :call matchdelete(a_id)<cr>
        "\     nno  ,R :call clearmatches()<cr>


ä¸éœ€è¦äº†, åœ¨"
è¿™é‡ŒåŠ äº†:
syn cluster vimOperGroup    contains=vimEnvvar,
                                        \vimFunc,
                                        \vimFuncVar,
                                        \vimOper,
                                        \vimOperParen,
                                        \vimNumber,
                                        \vimStr,
                                        \vimType,
                                        \vimRegister,
                                        \vimContinue,
                                        \vimVar,
                                        \vimContinue,
                                        \vimComment,
                                        \vimLineComment,
                                        \Vim_com_delI

    "\ "\ è¿™ä¸ªç”¨syntax matchçš„è¯, è¢«dictçš„syntaxè¦†ç›–
    "\ let g:backslash_iD = matchadd(
    "\                         \ 'Comment',
    "\                         \ '\v^\s*\zs' . '"\\' . '.*$',
    "\                         \ 200,
    "\                         \ -1,
    "\                         \ )
    "\ let g:backslash_iD = matchadd(
    "\                         \ 'Conceal',
    "\                         \ '\v^\s*\zs' . '"\\ ' . '\ze.*$',
    "\                         \ 201,
    "\                         \ -1,
    "\                         \ )
" ç»™windowsçš„neovideç”¨,
" vide
    " è¿™ä¸ªä¹‹å‰è¡Œ
    " ä¸çŸ¥é“ä¸ºå•¥åˆä¸è¡Œäº†
    " let $nV = "C:\Users\noway\AppData\Local\nvim"
    "
    " è¿™ä¸ªifèƒ½ç”Ÿæ•ˆ?
        " if has('win32')
            " let $nV = "C:\Users\noway\AppData\Local\nvim"

        " else
            " let $nV = $cfg_X.."/nvim"
        " en



fun! Smart_subS()
    "\ æœ¬æ¥æƒ³åœ¨æœ¬å‡½æ•°é‡Œ ä¸€ç»Ÿnormalå’Œvisualçš„map, ä½†å¤±è´¥
        "\ let @t = @"
        "\ éƒ½åªèƒ½æ˜¾ç¤º'c', è€Œénormal æˆ–visual
            "\ echom "mode() æ˜¯: "   mode()
            "\ echom "nvim_get_mode() æ˜¯: "   nvim_get_mode()
        "\ if mode() == 'n'
        "\     echom 'è¿›æ¥näº†'
        "\     echom 'before  @fæ˜¯' @f
        "\     norm viw
        "\     echom 'after @fæ˜¯' @f
        "\ el
        "\     norm! `<v`>"fy
        "\     "\ ä¸è¡Œ:
        "\     "\ norm! '<v'>"fy
        "\ en

    let @" = @0
        "\ æ–¹ä¾¿æ•²<c-g>ç²˜è´´

    if @f !~  '@'
        return '.,$  sub  @\v@@gc'
    el
        if @f !~ '#'
            return '.,$  sub  #\v##gc'
        el
            return '.,$  sub  /\v//gc'
        en
    en
endf



"\ è¿™ç‰ˆæœ‰ç‚¹ä¸‘

        "\ exe ' cnorea'
        "\         \ a:_in
        "\         \ '<c-r>=(getcmdtype() == ":" && getcmdpos()==1 ? '''.. a:_out.. ''' : '''..a:_in..''')<CR>'

        " exe 'cnorea'
        "         \ s_in
        "         \ '<c-r>=(getcmdtype() == ":" && getcmdpos()==1 ? '''.. s_out.. ''' : '''..s_in..''')<cr>'
        " å½¢å¦‚:
            " cnorea  h <c-r>=(getcmdtype()==':' && getcmdpos()==1 ? '-tab help' : 'h')<CR>
                                                 "  getcmdpos==1    åœ¨è¾“å…¥s_inæ—¶, ä»…å½“å…‰æ ‡ä½äºå‘½ä»¤è¡Œæœ€å¼€å¤´, æ‰å˜ä¸ºa:_out


        nno <M-,>  <cmd>call LeftN(2)<cr>
            func! LeftN(n_space)
                let bk_backspace = &backspace
                set backspace=start
                    " åˆ¨æ‰eol,

                set noshiftround   tabstop=1

                let a_list = getcurpos()
                "\ è¿”å›å½¢å¦‚ [0, 81, 30, 0, 30],
                         "\ [buf, line, col, off, cusorwant]
                                              "curswant":  number,
                                                            "\ the preferred column  when moving the  cursor vertically
                         "\ ç¬¬ä¸€ä¸ªè¡¨ç¤ºbuffer, æ°¸è¿œæ˜¯0 (å½“å‰buffer)
                "\ norm! g^i
                norm I
                exe 'norm!' repeat('', a:n_space)
                call cursor(a_list[1:])
                exe 'norm!' repeat('h', a:n_space)

                "\ å±å¹•ä¼š"æ™ƒ":
                "\ norm!  mt
                "\ exe 'norm I'
                "\ exe 'norm!' repeat('', a:n_space)
                "\ norm! `t
                "\ exe 'norm!' repeat('h', a:n_space)


                set tabstop=4     shiftround
                let &backspace = bk_backspace
            endf

